name: Deploy to Production

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
      - uses: actions/checkout@v2
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1
        
      # Installer Docker Compose v2
      - name: Install Docker Compose v2
        run: |
          # Vérifier d'abord si docker compose fonctionne déjà
          if docker compose version; then
            echo "Docker Compose v2 est déjà installé."
          else
            echo "Installation de Docker Compose v2..."
            # Méthode 1: Installation depuis les dépôts (peut échouer sur certains runners)
            sudo apt-get update || true
            sudo apt-get install -y docker-compose-plugin || true
            
            # Méthode 2: Si la méthode 1 a échoué, installation manuelle
            if ! docker compose version; then
              echo "Installation manuelle de Docker Compose v2..."
              DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}
              mkdir -p $DOCKER_CONFIG/cli-plugins
              COMPOSE_VERSION="v2.23.3"
              sudo curl -SL "https://github.com/docker/compose/releases/download/${COMPOSE_VERSION}/docker-compose-linux-x86_64" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
              sudo ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose
            fi
          fi
          
          # Vérifier l'installation - utiliser docker compose ou docker-compose selon ce qui est disponible
          docker compose version || docker-compose version
      
      - name: Build and tag images
        run: |
          # Utiliser la commande qui fonctionne
          if docker compose version &> /dev/null; then
            docker compose build
          else
            docker-compose build
          fi
          
          docker tag ecm-monitoring-frontend:latest ghcr.io/${{ github.repository_owner }}/ecm_rework-frontend:${{ github.sha }}
          docker tag ecm-monitoring-backend:latest ghcr.io/${{ github.repository_owner }}/ecm_rework-backend:${{ github.sha }}
      
      # Connexion à GitHub Container Registry
      - name: Login to GitHub Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      # Push des images vers le registry
      - name: Push images
        if: github.event_name != 'pull_request' && env.PUSH_TO_REGISTRY == 'true'
        run: |
          docker push ghcr.io/${{ github.repository_owner }}/ecm_rework-frontend:${{ github.sha }}
          docker push ghcr.io/${{ github.repository_owner }}/ecm_rework-backend:${{ github.sha }}
          docker tag ghcr.io/${{ github.repository_owner }}/ecm_rework-frontend:${{ github.sha }} ghcr.io/${{ github.repository_owner }}/ecm_rework-frontend:latest
          docker tag ghcr.io/${{ github.repository_owner }}/ecm_rework-backend:${{ github.sha }} ghcr.io/${{ github.repository_owner }}/ecm_rework-backend:latest
          docker push ghcr.io/${{ github.repository_owner }}/ecm_rework-frontend:latest
          docker push ghcr.io/${{ github.repository_owner }}/ecm_rework-backend:latest
        env:
          PUSH_TO_REGISTRY: ${{ secrets.PUSH_TO_REGISTRY || 'false' }}
      
      # Vérification du build réussi sans déploiement (pour les tests initiaux)
      - name: Build Verification Success
        if: success() && (env.PUSH_TO_REGISTRY != 'true' || env.DEPLOY_TO_PRODUCTION != 'true')
        run: echo "✅ Build successful! Les images ont été construites avec succès. Pour activer le push au registry et le déploiement, configurez les secrets PUSH_TO_REGISTRY et DEPLOY_TO_PRODUCTION."
      
      # Génération du fichier docker-compose.prod.yml
      - name: Generate Production Docker Compose File
        if: success() && env.DEPLOY_TO_PRODUCTION == 'true'
        run: |
          cat > docker-compose.prod.yml << EOF
          services:
            database:
              image: mysql:8.0
              restart: unless-stopped
              environment:
                MYSQL_ROOT_PASSWORD: \${MYSQL_ROOT_PASSWORD:-root}
                MYSQL_DATABASE: \${MYSQL_DATABASE:-synergy}
                MYSQL_USER: \${MYSQL_USER:-}
                MYSQL_PASSWORD: \${MYSQL_PASSWORD:-}
              volumes:
                - mysql_data:/var/lib/mysql
                - ./server/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
              ports:
                - "\${DB_PORT:-3306}:3306"
              networks:
                - app-network
          
            backend:
              image: ghcr.io/${{ github.repository_owner }}/ecm_rework-backend:${{ github.sha }}
              restart: unless-stopped
              environment:
                NODE_ENV: \${NODE_ENV:-production}
                DB_HOST: \${DB_HOST:-database}
                DB_NAME: \${DB_NAME:-synergy}
                DB_USER: \${DB_USER:-root}
                DB_PASSWORD: \${DB_PASSWORD:-root}
                DB_SYNC_ALTER: \${DB_SYNC_ALTER:-"false"}
                JWT_SECRET: \${JWT_SECRET:-your-secret-key}
                CLIENT_URL: \${CLIENT_URL:-http://localhost}
                SERVER_PORT: \${SERVER_PORT:-5001}
              volumes:
                - ./server/uploads:/app/uploads
              ports:
                - "\${SERVER_PORT:-5001}:5001"
              depends_on:
                - database
              networks:
                - app-network
          
            frontend:
              image: ghcr.io/${{ github.repository_owner }}/ecm_rework-frontend:${{ github.sha }}
              restart: unless-stopped
              ports:
                - "\${CLIENT_PORT:-80}:80"
              depends_on:
                - backend
              networks:
                - app-network
          
          volumes:
            mysql_data:
              driver: local
          
          networks:
            app-network:
              driver: bridge
          EOF
      
      # Cette étape ne s'exécute que si DEPLOY_TO_PRODUCTION est true
      - name: Deploy to production
        if: success() && env.DEPLOY_TO_PRODUCTION == 'true'
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ secrets.PROD_HOST }}
          username: ${{ secrets.PROD_USERNAME }}
          key: ${{ secrets.PROD_SSH_KEY }}
          script: |
            # Créer le répertoire de déploiement s'il n'existe pas
            mkdir -p /opt/ecm-monitoring
            cd /opt/ecm-monitoring
            
            # Configuration du login GitHub Container Registry
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Copie des fichiers nécessaires
            cat > docker-compose.yml << 'EOL'
            services:
              database:
                image: mysql:8.0
                restart: unless-stopped
                environment:
                  MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD:-root}
                  MYSQL_DATABASE: ${MYSQL_DATABASE:-synergy}
                  MYSQL_USER: ${MYSQL_USER:-}
                  MYSQL_PASSWORD: ${MYSQL_PASSWORD:-}
                volumes:
                  - mysql_data:/var/lib/mysql
                  - ./server/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
                ports:
                  - "${DB_PORT:-3306}:3306"
                networks:
                  - app-network
            
              backend:
                image: ghcr.io/${{ github.repository_owner }}/ecm_rework-backend:${{ github.sha }}
                restart: unless-stopped
                environment:
                  NODE_ENV: ${NODE_ENV:-production}
                  DB_HOST: ${DB_HOST:-database}
                  DB_NAME: ${DB_NAME:-synergy}
                  DB_USER: ${DB_USER:-root}
                  DB_PASSWORD: ${DB_PASSWORD:-root}
                  DB_SYNC_ALTER: ${DB_SYNC_ALTER:-"false"}
                  JWT_SECRET: ${JWT_SECRET:-your-secret-key}
                  CLIENT_URL: ${CLIENT_URL:-http://localhost}
                  SERVER_PORT: ${SERVER_PORT:-5001}
                volumes:
                  - ./server/uploads:/app/uploads
                ports:
                  - "${SERVER_PORT:-5001}:5001"
                depends_on:
                  - database
                networks:
                  - app-network
            
              frontend:
                image: ghcr.io/${{ github.repository_owner }}/ecm_rework-frontend:${{ github.sha }}
                restart: unless-stopped
                ports:
                  - "${CLIENT_PORT:-80}:80"
                depends_on:
                  - backend
                networks:
                  - app-network
            
            volumes:
              mysql_data:
                driver: local
            
            networks:
              app-network:
                driver: bridge
            EOL
            
            # Vérifier s'il existe déjà un fichier .env, sinon le créer
            if [ ! -f .env ]; then
              echo "Création du fichier .env par défaut..."
              cat > .env << 'EOL'
              MYSQL_ROOT_PASSWORD=root_password_secure
              MYSQL_DATABASE=synergy
              DB_HOST=database
              DB_NAME=synergy
              DB_USER=root
              DB_PASSWORD=root_password_secure
              JWT_SECRET=change_this_to_a_secure_random_string
              NODE_ENV=production
              EOL
            fi
            
            # Vérifier si le répertoire server/uploads existe, sinon le créer
            mkdir -p server/uploads
            
            # Copier le fichier d'initialisation SQL s'il n'existe pas
            mkdir -p server
            if [ ! -f server/init.sql ]; then
              echo "CREATE DATABASE IF NOT EXISTS synergy;" > server/init.sql
            fi
            
            # Sur le serveur de production, déployer avec docker compose
            if command -v docker compose &> /dev/null; then
              docker compose pull
              docker compose down
              docker compose up -d
            else
              docker-compose pull
              docker-compose down
              docker-compose up -d
            fi
            
            echo "Déploiement terminé avec succès!"
        env:
          DEPLOY_TO_PRODUCTION: ${{ secrets.DEPLOY_TO_PRODUCTION || 'false' }}
